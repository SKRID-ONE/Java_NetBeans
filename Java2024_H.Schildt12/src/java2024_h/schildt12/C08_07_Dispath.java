/*
Динамическая диспетчеризация методов
 */
package java2024_h.schildt12;

/**
Именно тип объекта, на который делается ссылка (а не тип ссылочной переменной), 
* определяет, какая версия переопределенного метода будет выполняться. Таким образом, если 
суперкласс содержит метод, который переопределяется в подклассе, то при 
ссыл ке на разные типы объектов через ссылочную переменную типа супер-класса выполняются разные версии метода
 */
public class C08_07_Dispath {
    public static void main (String [] args) {
        
        //Создание объектов
        A2 aa = new A2();
        B2 bb = new B2();
        C2 cc = new C2();
        
        
        A2 r; // создание ссылки типа А2.\
        r = aa; //r ссылается на объект типа A2
        r.callme(); // вызывает метод из А2
        
        r=bb;//r ссылается на объект типа B2
        r.callme(); // вызывает метод из B2
        
        r=cc;//r ссылается на объект типа C2
        r.callme(); // вызывает метод из C2
        
        
        
        //TEST
        System.out.println("TEST");
        A2 test = new C2(); // Создание ссылки Суперкласса на объект субкласса
        test.callme();
        
    }
}
/*
В выводе видно, что выполняемая версия cal lme () определяется типом объекта, 
на который делается ссылка во время вызова. Если бы версия определялась типом 
ссылочной переменной r, то вы бы увидели три вызова метода callme () класса А. 
*/

class A2 {
    void callme(){
        System.out.println("It's A class");
    }
}

class B2 extends A2 {
    void callme(){
        System.out.println("It's B class");
    }
}

class C2 extends A2 {
    void callme(){
        System.out.println("It's C class");
    }
}